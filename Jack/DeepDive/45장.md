## 프로미스

### 비동기 처리를 위한 콜백 패턴의 단점

1. 콜백 헬
- 위 함수는 비동기 함수이기 때문에 비동기 함수가 종료된 이후에 완료되므로 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.

- 위 상황에서 get 함수의 반환문은 생략되었으므로 암묵적으로 undefined를 반환한다. onload 이벤트 핸들러는 get 함수가 호출하지 않기때문에 이벤트 핸들러의 반환값을 get 함수가 캐치할 수 없고, 상위스코프를 사용한다 하더라도 이벤트 핸들러 프로퍼티에 바인딩한 이벤트 핸들러는 전역코드의 실행이 끝난다음 실행되기 때문에 확인할 수 없다.

- 이처럼 비동기 함수는 비동기 처리를 외부에 반환할수 없고, 상위 스코프의 변수에 할당할 수 없어서 비동기 함수의 처리 결과에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다. --> 콜백함수를 이용

- const get = (url, successCallback, failureCallback) => { ... }

- get('url', console.log, console.error);
- 그러나 이 방법은 비동기 함수가 비동기 처리 결과를 가지고 비동기 함수를 호출하여 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상을 발생시킬 수 있다. --> 콜백 헬

2. 에러 처리의 한계
- 위 예제에서는 setTimeout 함수가 실행 컨텍스트 스택에 들어가 호스트에게 호출 스케줄링을 부탁하고 바로 종료되기 때문에 실행 컨텍스트 스택에서 제거된 상태이므로 캐치 블록에서 잡히지 않는다.
에러는 호출자 방향으로 전파되어 콜 스택의 아래 방향으로 전파되는데, 저 함수가 호출될때의 콜 스택에는 아무것도 없기 때문에 에러를 잡을 수가 없다.

- try...catch...finally 문은 try 코드 블록이 실행되고 그 중 에러가 발생하면 catch 문의 err 변수로 전달되어 catch 블록이 실행된다. finally 블록은 에러 발생과 상관없이 반드시 한 번 실행된다. 이렇게 에러를 처리하면 프로그램이 강제 종료 되지 않는다.

### 프로미스의 생성
- new 연산자와 함께 Promise를 호출하여 생성하고 이는 ECMAScript 사양에 정의된 표준 빌트인 객체이다.
resolve, reject함수를 인수로 받는다.

- 아까 위에서 작성했던 코드를 promise를 사용하면 다음과 같이 작성할 수 있다. 달라진 부분은 반환하는 것이 new Promise 이며 인자로 resolve, reject를 사용하여 성공 시, resolve 함수를, 실패 시 reject 함수를 호출한다. 둘다 프로미스를 반환한다.

- 프로미스 상태 정보	의미	상태 변경 조건
- pending	비동기 처리가 아직 수행되지 않은 상태	프로미스가 생성된 직후 기본 상태
- fulfilled	비동기 처리가 수행된 상태(성공)	resolve 함수 호출
- rejected	비동기 처리가 수행된 상태(실패)	reject 함수 호출
- 생성된 직후의 프로미스는 기본적으로 pending 상태. 비동기 처리 결과에 따라 프로미스의 상태가 변경된다.

- 비동기 처리 성공: resolve 함수를 호출해 프로미스를 fulfilled 상태로 변경
- 비동기 처리 실패: reject 함수를 호출해 프로미스를 rejected 상태로 변경
- 비동기 처리가 수행된 상태를 settled 상태라고 한다.(다른 상태로 변화 불가능)

- PromiseStatus = 비동기 처리 상태 정보
- PromiseValue = 비동기 처리 결과 정보
- 프로미스는 비동기 처리 상태와 결과를 관리하는 객체이다.

### 프로미스의 후속 처리 메서드
- then, catch, finally를 제공한다. 프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다. 모든 후속 처리 메서드는 프로미스를 반환하고 비동기로 동작한다.

1. Promise.prototype.then = 두 개의 콜백함수를 인수로 전달받는다.

- 첫 번째 콜백 함수는 프로미스가 fulfilled 상태가 되면 호출된다. -> 콜백함수는 프로미스의 비동기 처리 결과를 인수로 전달받음
- 두 번째 콜백 함수는 프로미스가 rejected 상태가 되면 호출된다. -> 이때 콜백함수는 프로미스의 에러를 인수로 전달받는다.
- 언제나 프로미스를 반환하고, 콜백 함수가 프로미스 반환 시 그대로 반환하고 아닌 값을 반환하면 그 값을 암묵적으로 resolve, reject 하여 프로미스를 생성해 반환

2. Promise.prototype.catch = 한 개의 콜백 함수를 인수로 전달받는다. 프로미스가 rejected 상태인 경우만 호출된다.

3. Promise.prototype.finally = 한 개의 콜백 함수를 인수로 전달받고, 프로미스의 성공 또는 실패와 상관없이 무조건 한 번 호출된다. --> 공통적으로 수행해야 할 처리 내용이 있을 때 유용하며 언제나 프로미스를 반환한다.


### 프로미스의 에러 처리
- 아까 위에서 적은 promiseGet의 resolve, reject는 프로미스를 반환하므로 then, catch, finally등의 후속 처리메서드를 사용할 수 있다.

- 에러를 처리하는 경우 then 메서드의 두 번째 콜백 함수로 처리하거나 catch를 사용해 처리할 수 있는데, catch 메서드는 내부적으로 then(undefined, onRejcted)를 호출하는 것과 같다. 그러나 아래의 상황 때문에 then 메서드보다 catch 메서드를 사용하는 것이 가독성이 좋고 명확하다.

- 위 코드의 각각의 결과는 위 사진과 같다. then 메서드 사용시 첫번째 콜백 함수에서 발생한 에러를 캐치하지 못해 Uncaught ~ 에러가 발생하며, catch 메서드를 사용 시 비동기 처리에서 발생한 에러 뿐만 아니라 then 메서드 내부에서 발생한 에러까지 모두 캐치가 가능하다. (TypeError 발생)

### 프로미스 체이닝
- then, catch, finally 후속 처리 메서드는 언제나 프로미스를 반환하기 때문에 연속적으로 호출할수 있고 이를 프로미스 체이닝 이라고 한다.

- 이 프로미스 체이닝을 통해 비동기 처리 결과를 받아 후속 처리를 하므로 콜백 헬이 발생하지 않는다. 그러나 결국 promise도 콜백 패턴을 사용하므로 콜백함수를 사용하지 않는 것은 아니다.

- 콜백 패턴은 가독성이 좋지 않은데 이 문제를 async/await를 통해 해결할 수 있다. --> 동기 처리처럼 프로미스가 처리 결과를 반환하도록 함.

### 프로미스의 정적 메서드
- Promise는 주로 생성자 함수로 사용되지만 함수도 객체이므로 메서드를 가지며 5가지 정적 메서드를 제공한다.

1. Promise.resolve / Promise.reject
- resolve와 reject 메서드는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다. 인수로 전달받은 값 resolve하는 프로미스 생성

- 뒤에 then 후속 처리 메서드 붙여서 console.log 찍으면 [1, 2, 3] 나옴
reject도 마찬가지로 인수로 전달 받은 값을 reject 하는 프로미스를 생성한다.

2. Promise.all
- 여러 개의 비동기 처리를 모두 병렬 처리할때 사용한다.
- 이 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달 받는다. 모든 promise가 fulfilled 상태가 되면 모든 처리 결과를 배열에 저장해 새로운 프로미스를 반환한다.

- 이 메서드가 종료되는 시간은 가장 늦게 fulfilled 상태가 되는 프로미스의 처리 시간보다 약간 더 김(가장 긴 시간이 3초라면 3초 + 알파가 모든 처리에 걸리는 시간)

- 이 메서드는 첫 번째 프로미스가 resolve한 처리 결과부터 차례대로 배열에 저장하기 때문에 처리 순서가 보장되며 하나라도 rejected 상태가 되면 그 즉시 종료한다.

- 인수로 전달받은 요소가 프로미스가 아닌 경우 resolve 메서드를 통해 프로미스로 래핑함

3. Promise.race
- Promise.all 메서드 처럼 동일하게 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.

- 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve하는 새로운 프로미스를 반환한다. 그러나 하나라도 rejected 상태가 되면 에러를 reject하는 새로운 프로미스를 즉시 반환한다.(promise.all처럼)

4. Promise.allSettled
- 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받고 전달받은 프로미스가 모두 settled 상태가 되면 처리 결과를 배열로 반환한다.

- 프로미스가 fulfilled 상태인 경우 비동기 처리상태를 나타내는 status 프로퍼티와 처리 결과를 나타내는 value 프로퍼티를 갖는다
- 프로미스가 rejected 상태인 경우 비동기 처리 상태를 나타내는 status 프로퍼티와 에러를 나타내는 reason 프로퍼티를 갖는다.

### 마이크로태스크 큐
- 마이크로태스크 큐와 태스트 큐와는 별도의 큐인데 안에 저장되는 것들이 다르다
- 마이크로태스크 큐 -> 프로미스의 후속 처리 메서드의 콜백 함수
- 태스크 큐 -> 비동기 함수의 콜백함수나 이벤트 핸들러
- 마이크로태스크 큐가 태스크 큐보다 우선순위가 높다.(콜 스택이 비면 마이크로태스크 큐먼저 확인 후 태스크 큐 진행)

### fetch
- XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 API 이다. 사용법이 간단하고 프로미스를 지원하여 콜백 패턴의 단점에서 자유롭다.

- fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다.

- response객체는 HTTP 응답을 나타내는 다양한 프로퍼티와 메서드를 제공하는데, MIME 타입이 application/json인 응답 몸체를 취득하려면 Response.prototype.json 메서드를 사용한다.(역 직렬화를 위해)